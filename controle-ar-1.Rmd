---
title: "CC para resíduos AR(1)"
output:
  html_document:
    df_print: paged
    theme: paper
    highlight: tango
    toc: true
    toc_float:
      collapsed: true
    code_folding: hide
---

<style>
body {
  font-size: 15px;
}

.table {
  font-size: 12px;
}

.table caption {
  font-size: 13px;
  color: gray;
  font-weight: 600;
}

p {
  text-align: justify;
  text-justify: distribute;
}

.meme-block {
    padding-top: 12px;
}

.meme-block .meme p {
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
}

.meme-block .meme-img {
    display: block;
    max-width: 150px;
    max-height: 150px;
    width: auto;
    height: auto;
}

.bg-danger:not(#dummy) {
  background-color: #f9bdbb;
}

#chart-zoom-modal .modal-dialog {
  width: auto;
  margin: 10px;
}

#chart-zoom-modal .chart-image-preview-wrapper {
  display: flex;
  justify-content: center;
}

#chart-zoom-modal .chart-image-preview {
  width: auto;
  height: 100%;
  max-height: 90vh;
}

.chart-image-wrapper #chart-zoom-button {
  position: absolute;
  top: 0;
  right: 0;
}

.modal-actions {
  position: absolute;
  display: flex;
  justify-content: space-between;
  flex-direction: row-reverse;
  width: calc(100vw - 50px);
}

.modal-actions button {
  opacity: 0.8;
}

.modal-actions button:hover:not(:disabled) {
  opacity: 1;
}
</style>

<script type="text/javascript">
  $(document).ready(function() {
    $('body').prepend(
      // Modal component
      `<div class="modal fade" id="chart-zoom-modal" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content">
            <div class="modal-body">
              <div class="modal-actions">
                <div>
                  <!-- Fullscreen button -->
                  <button type="button" class="btn btn-default btn-sm" id="chart-fullscreen">
                    <span class="glyphicon glyphicon-resize-full"></span>
                  </button>
                  <!-- Close button -->
                  <button type="button" class="btn btn-default btn-sm" data-dismiss="modal">
                    <span class="glyphicon glyphicon-remove"></span>
                  </button>
                </div>
                <!-- Navigation buttons -->
                <div class="modal-navigate">
                  <button type="button" class="btn btn-default btn-sm" id="chart-zoom-prev">
                    <span class="glyphicon glyphicon-chevron-left"></span>
                  </button>
                  <button type="button" class="btn btn-default btn-sm" id="chart-zoom-next">
                    <span class="glyphicon glyphicon-chevron-right"></span>
                  </button>
                </div>
              </div>
              <!-- Chart image -->
              <div class="chart-image-preview-wrapper">
                <img src="" class="chart-image-preview" keepaspectratio="true">
              </div>
            </div>
          </div>
        </div>
      </div>`
    );
    // Add zoom button on top right of each chart
    $('p>img.chart-image').each(function(index) {
      $(this).wrap('<div class="chart-image-wrapper" style="position: relative;"></div>');
      // Add data attribute to identify chart index
      $(this).attr('data-chart-index', index);
      // Button to zoom in
      $(this).parent().append(
        `<button type="button" id="chart-zoom-button" class="btn btn-default btn-sm" data-chart-index="${index}">
          <span class="glyphicon glyphicon-zoom-in"></span>
        </button>`
      );
      // Chart click event
      $(this).siblings('#chart-zoom-button').on('click', function() {
        var chartIndex = $(this).data('chart-index');
        $(`img.chart-image-preview`).attr('src', $(`img.chart-image[data-chart-index=${chartIndex}]`).attr('src'));
        $(`img.chart-image-preview`).attr('data-chart-index', chartIndex);
        updateNavButtonsState();
        // Remove class to avoid fullscreen
        removeFullscreen();
        // Show modal
        $('#chart-zoom-modal').modal('show');
      });
    });
    // Fullscreen button
    $('#chart-fullscreen').on('click', function() {
      toggleFullScreen();
    });
    // Modal navigate buttons
    $('#chart-zoom-prev').on('click', function() {
      showPrevChart();
    });
    $('#chart-zoom-next').on('click', function() {
      showNextChart();
    });
    // Modal arrow keys to navigate charts
    $(document).keydown(function(e) {
      if ($('#chart-zoom-modal').is(':visible')) {
        if (e.keyCode == 37) {
          showPrevChart();
          e.preventDefault();
        } else if (e.keyCode == 39) {
          showNextChart();
          e.preventDefault();
        }
      }
    });
    function removeFullscreen() {
      $(`img.chart-image-preview`).removeClass('fullscreen');
      $(`img.chart-image-preview`).css('max-height', '90vh');
      $('#chart-fullscreen').find('span').removeClass('glyphicon-resize-small').addClass('glyphicon-resize-full');
    }
    function addFullscreen() {
      $(`img.chart-image-preview`).addClass('fullscreen');
      $(`img.chart-image-preview`).css('max-height', 'none');
      $('#chart-fullscreen').find('span').removeClass('glyphicon-resize-full').addClass('glyphicon-resize-small');
    }
    function toggleFullScreen(fullScreenState) {
      if ($(`img.chart-image-preview`).hasClass('fullscreen')) {
        removeFullscreen();
      } else {
        addFullscreen();
      }
    }
    function showPrevChart() {
      var chartIndex = parseInt($(`img.chart-image-preview`).attr('data-chart-index'));
      if (chartIndex > 0) {
        chartIndex -= 1;
        $(`img.chart-image-preview`).attr('src', $(`img.chart-image[data-chart-index=${chartIndex}]`).attr('src'));
        $(`img.chart-image-preview`).attr('data-chart-index', chartIndex);
        updateNavButtonsState();
      }
    }
    function showNextChart() {
      var chartIndex = parseInt($(`img.chart-image-preview`).attr('data-chart-index'));
      if (chartIndex < $('img.chart-image').length - 1) {
        chartIndex += 1;
        $(`img.chart-image-preview`).attr('src', $(`img.chart-image[data-chart-index=${chartIndex}]`).attr('src'));
        $(`img.chart-image-preview`).attr('data-chart-index', chartIndex);
        updateNavButtonsState();
      }
    }
    // Disable nav buttons if at the end
    function updateNavButtonsState() {
      var chartIndex = parseInt($(`img.chart-image-preview`).attr('data-chart-index'));
      if (chartIndex == 0) {
        $('#chart-zoom-prev').prop('disabled', true);
      } else {
        $('#chart-zoom-prev').prop('disabled', false);
      }
      if (chartIndex == $('img.chart-image').length - 1) {
        $('#chart-zoom-next').prop('disabled', true);
      } else {
        $('#chart-zoom-next').prop('disabled', false);
      }
    }
  });
</script>

```{r echo=TRUE, message=FALSE, warning=FALSE}
Sys.setenv(lang = "en_US")

library(ggplot2)
library(forecast) # plot ts objects
library(knitr)
library(grid) # textGrob
library(gridExtra) # grid.arrange
library(latex2exp) # latex expressions
library(tidyr)
library(dplyr)
```

```{r}
knitr::opts_chunk$set(
  out.height = "\\textheight",
  out.width = "\\textwidth",
  out.extra = 'keepaspectratio=true class="chart-image"',
  fig.align = "center"
)
```


```{r}
theme.base <- theme_minimal(base_size = 11) +
  theme(
    axis.text = element_text(size = 8),
    plot.title = element_text(hjust = 0.5, size = 10, face = "bold"),
    axis.title = element_text(size = 8),
    legend.title = element_text(size = 8),
    panel.grid.major = element_line(colour = "grey90", linewidth = 0.5),
    panel.grid.minor = element_line(colour = adjustcolor("grey90", alpha.f = 0.4), linewidth = 0.5),
    panel.border = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    axis.line.x = element_line(colour = "grey"),
    axis.line.y = element_line(colour = "grey"),
  )

theme.no_legend <- theme(legend.position = "none")

theme.no_grid <-  theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()
)

theme.no_axis <- theme(
  axis.line.x = element_blank(),
  axis.line.y = element_blank()
)

theme.no_axis_title <- theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank()
)

# Theme for timeseries
theme.ts <- theme.base +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  ) +
  theme.no_legend

```


```{r}
# Função para simulação de amostras de um AR(1)
# 
# @param parametros lista com os parâmetros do modelo AR(1):
# \describe{
#   \item{n}{número de observações}
#   \item{phi}{parâmetro de auto-regressão}
#   \item{media}{média da distribuição do efeto aleatório}
#   \item{sd}{desvio padrão da distribuição do efeto aleatório}
#   \item{x0}{valor inicial da série}
# }
#
# @return vetor com a série simulada
# 
# @examples
# simulacao_ar_1(list(n = 10, phi = 0.5))
#
simulacao_ar_1 <- function(parametros) {
  if (!is.list(parametros)) stop("Os parâmetros devem ser passados em uma lista, por exemplo: list(n = 10, phi = 0.5)")
  if (!all(c("n", "phi") %in% names(parametros))) stop("Os parâmetros 'n' e 'phi' são obrigatórios")
  
  n <- parametros$n + 1
  
  media_pop <- ifelse(!is.numeric(parametros$media), 0, parametros$media)
  sd_pop <- ifelse(!is.numeric(parametros$sd), 1, parametros$sd)

  serie <- numeric(n)
  ifelse(is.null(parametros$x1), serie[1] <- rnorm(1), serie[1] <- parametros$x0)
  for (i in 2:n) {
    serie[i] <- parametros$phi * serie[i - 1] + rnorm(1, mean = media_pop, sd = sd_pop)
  }
  
  return(serie[-1])
}

```



## Série para criação dos limites de controle

```{r}
PARAMETROS <- data.frame(
  phi = 0.2,
  media = 0,
  sd = 1,
  n_h0 = 100,
  n_h1 = 200
)

```


```{r}
set.seed(1)

gerar_amostra_inicial <- function(){
  amostra_inicial <- ts(simulacao_ar_1(list(n = PARAMETROS$n_h0, phi = PARAMETROS$phi)))
  modelo <- arima(amostra_inicial, order = c(1, 0, 0), include.mean = FALSE)
  residuos <- modelo$residuals
  
  list(
    serie = amostra_inicial,
    x0 = amostra_inicial[1],
    xn = amostra_inicial[PARAMETROS$n_h0],
    modelo = modelo,
    residuos = residuos,
    phi = coef(modelo)[[1]],
    sd_res = sd(residuos),
    media_res = mean(residuos)
  )
}

amostra_inicial <- gerar_amostra_inicial()
amostra_inicial$modelo
```
```{r}
grid.arrange(
  autoplot(amostra_inicial$serie) + ggtitle("Série simulada para criação dos limites de controle") + theme.base + theme.ts,
  ggAcf(amostra_inicial$serie) + ggtitle("ACF da série simulada") + theme.base,
  ggPacf(amostra_inicial$serie) + ggtitle("PACF da série simulada") + theme.base,
  layout_matrix = rbind(c(1, 1), c(2, 3))
)
```


```{r}
grid.arrange(
  autoplot(amostra_inicial$residuos) + ggtitle("Resíduos do modelo AR(1)") + theme.base + theme.ts,
  ggAcf(amostra_inicial$residuos) + ggtitle("ACF dos resíduos") + theme.base,
  ggPacf(amostra_inicial$residuos) + ggtitle("PACF dos resíduos") + theme.base,
  layout_matrix = rbind(c(1, 1), c(2, 3))
)
```

### Limites de controle


```{r message=FALSE, warning=FALSE}
alpha <- 0.05
max_devio <- qnorm(1 - alpha/2) * amostra_inicial$sd_res
limites <- mean(amostra_inicial$residuos) + c(-max_devio, max_devio)

tabela_estatisticas_residuos <- function() {
  tabela <- data.frame(
    "mean" = amostra_inicial$media_res,
    "sd" = amostra_inicial$sd_res,
    "IL" = limites[1],
    "SL" = limites[2]
  )
  colnames(tabela) <- c("Média", "Desvio padrão", "Limite inferior", "Limite superior")
  t(tabela)
}

knitr::kable(
  tabela_estatisticas_residuos(),
  caption = "Intervalo de confiança dos resíduos",
  align = 'c',
  digits = 3
)
```


```{r message=FALSE, warning=FALSE}
phi_0_para_amostras_seguintes <- seq(0, 0.8, by = 0.1)
n_simulacoes <- length(phi_0_para_amostras_seguintes)

amostras_subsequentes <- lapply(
  phi_0_para_amostras_seguintes,
  function(phi_amostra) ts(simulacao_ar_1(list(n = PARAMETROS$n_h1, phi = phi_amostra, x0 = amostra_inicial$xn)))
)

```


## Simulações

Amostras subsequentes para $\phi_0 \in \{0, 0.1, 0.2, \ldots, 0.8\}$ com $n = 200$.


```{r, fig.height = 10}
graficos_series <- function(dados) {
  lista <- c()
  for (i in 1:(n_simulacoes)) {
    lista[[i]] <- autoplot(amostras_subsequentes[[i]]) +
      ggtitle(TeX(sprintf("$\\phi_0=%.1f$", phi_0_para_amostras_seguintes[i]))) +
      theme.base +
      theme.no_axis_title
  }
  lista
}

graficos_resid <- function(dados) {
  lista <- c()
  for (i in 1:(n_simulacoes)) {
    lista[[i]] <- ggAcf(amostras_subsequentes[[i]]) +
      ggtitle(TeX(sprintf("$\\phi_0=%.1f$", phi_0_para_amostras_seguintes[i]))) +
      theme.base +
      theme.no_axis_title
  }
  lista
}

grid.arrange(
  grobs = (
    \() {
      lista_graficos <- c()
      
      # Séries
      lista_graficos[[2]] <- textGrob("Séries", gp = gpar(fontface = "bold", fontsize = 12))
      lista_graficos[[3]] <- textGrob("")
      lista_graficos <- c(lista_graficos, graficos_series(amostras_subsequentes))
      
      # Resíduos
      lista_graficos[[length(lista_graficos) + 2]] <- textGrob("ACFs", gp = gpar(fontface = "bold", fontsize = 12))
      lista_graficos[[length(lista_graficos) + 1]] <- textGrob("")
      lista_graficos <- c(lista_graficos, graficos_resid(amostras_subsequentes))
      lista_graficos
    }
  )(),
  ncol = 3,
  widths = c(1, 1, 1)
)

```

## Cartas de controle para os resíduos


```{r}
residuos_subsequentes <- lapply(amostras_subsequentes, function(amostra) Arima(amostra, model = amostra_inicial$modelo)$residuals)

cartas_controle <- function(dados) {
  lista <- c()
  for (i in 1:(n_simulacoes)) {
    residuos <- residuos_subsequentes[[i]]
    resid_layer <- autolayer(residuos_subsequentes[[i]])
    fora_de_controle = resid_layer$layer_data() %>% filter(seriesVal < limites[1] | seriesVal > limites[2])
    
    lista[[i]] <- autoplot(residuos) +
      geom_hline(yintercept = limites, linetype = "dashed", color = "red", alpha = 0.6) +
      geom_point(data = fora_de_controle, aes(x = timeVal, y = seriesVal), color = "red") +
      theme.base +
      theme.no_axis_title +
      theme(legend.position = "none") +
      labs(x = "Resíduos", y = "Observação") +
      ggtitle(TeX(sprintf("$\\phi_0=%.1f$", phi_0_para_amostras_seguintes[i])))
  }
  lista
}

grid.arrange(
  grobs = (
    \() {
      lista_graficos <- c()
      lista_graficos[[2]] <- textGrob("Resíduos", gp = gpar(fontface = "bold", fontsize = 12))
      lista_graficos[[3]] <- textGrob("")
      lista_graficos <- c(lista_graficos, cartas_controle(amostras_subsequentes))
      lista_graficos
    }
  )(),
  ncol = 3,
  widths = c(1, 1, 1)
)
```

### Quantidade de amostras fora de controle para cada $\phi_0$

```{r results = 'asis'}
quantidade_fora_de_controle <- sapply(residuos_subsequentes, function(residuos) {
  sum(residuos < limites[1] | residuos > limites[2])
})

tabela_estatisticas_amostras <- function() {
  tabela <- data.frame(
    "phi_0" = phi_0_para_amostras_seguintes,
    "fora" = quantidade_fora_de_controle,
    "prop" = 100 * quantidade_fora_de_controle / PARAMETROS$n_h1
  )
  colnames(tabela) <- c("$\\phi_0$", "Amostras fora de controle", "Proporção (%)")
  tabela
}

ggplot(tabela_estatisticas_amostras(), aes(x = `$\\phi_0$`, y = `Proporção (%)`)) +
  geom_point() +
  geom_line() +
  labs(x = TeX("$\\phi_0$"), y = "Porcentagem fora de controle") +
  ggtitle(TeX("Porcentagem de amostras fora de controle para cada $\\phi_0$")) +
  theme.base

kable(
  tabela_estatisticas_amostras(),
  caption = "Quantidade de amostras fora de controle para cada $\\phi_0$",
  align = 'c',
  digits = 3
)

```



## EWMA-AR

Minimizando a soma dos quadrados dos resíduos para encontrar o melhor valor de $\lambda$.

Temos que $\lambda \in (0, 1]$, além disso, a previsão para a observação $x_{t+1}$ é dada por $\hat{x}_{t+1}(t)=z_{t} = \lambda x_t + (1 - \lambda) z_{t-1}$.
E, segundo Montgomery, Eq. 10.16, temos que os erros de previsão são dados por $e_t = x_t - \hat{x}_t(t-1)$.

Ou, de outra forma
$$\min\big(\underset{\lambda\in(0,1]}{\arg\min}\,\text{Err}(\lambda)\big)$$
onde $\text{Err}(\lambda) = \sum_{t=1}^{n} e_t^2$.


```{r message=FALSE, warning=FALSE}
ewma_ar <- function(dados, lambda) {
  n <- length(dados)
  ewma <- numeric(n)
  residuos <- numeric(n)
  ewma[1] <- dados[1]
  residuos[1] <- dados[1]
  for (i in 2:n) {
    ewma[i] <- lambda * dados[i] + (1 - lambda) * ewma[i - 1]
    residuos[i] <- dados[i] - ewma[i - 1]
  }
  data.frame(ewma = ewma, residuos = residuos)
}

# Salvando para plotar
lambdas_verificados <- c()
soma_quadrados <- c()

verifica_lambda <- function(lambda) {
  ewma <- ewma_ar(
    amostra_inicial$serie,
    lambda = lambda
  )
  soma <- sum(ewma$residuos^2)
  lambdas_verificados <<- c(lambdas_verificados, lambda)
  soma_quadrados <<- c(soma_quadrados, soma)
  soma
}

lambda_otimo <- optimize(verifica_lambda, c(0.000001, 1))
lambdas_df <- data.frame(lambda = lambdas_verificados, erro = soma_quadrados)
```




```{r message=FALSE, warning=FALSE}
ggplot(data = lambdas_df) +
  geom_line(aes(x = lambda, y = erro)) +
  geom_vline(xintercept = lambda_otimo$minimum, linetype = "dashed", color = "red") +
  annotate("text", x = lambda_otimo$minimum, y = 0,
           label = TeX(sprintf("$\\lambda=%.3f$", lambda_otimo$minimum)), color = "red",
           hjust = -0.1, vjust = -0.2, na.rm = T, angle = 90) +
  labs(x = TeX("$\\lambda$"), y = "Soma dos quadrados dos resíduos") +
  ggtitle(TeX("Soma dos quadrados dos resíduos para diferentes valores de $\\lambda$ com o modelo ARIMA")) +
  theme.base
```



Segundo Montgomery, podemos estimar o valor de $\sigma^2$ para o modelo EWMA-AR como $\sigma^2 = \frac{\sum (\text{err}_i^2|_\lambda)}{n}$. Onde $\text{err}|_\lambda$ são os resíduos do modelo EWMA-AR para o melhor valor de $\lambda$ encontrado.



```{r}
sigma2_lambda <- lambda_otimo$objective / PARAMETROS$n_h0
sigma2_sd <- amostra_inicial$sd_res

tabela_estatistivas_sigma2 <- function() {
  tabela <- data.frame(
    "modelo" = c("sd(modelo)", "min(Err)"),
    "lambda" = c(NA, lambda_otimo$minimum),
    "erro" = c(sum(amostra_inicial$residuos^2), lambda_otimo$objective),
    "sigma2" = c(sigma2_sd, sigma2_lambda)
  )
  colnames(tabela) <- c("Modelo", "$\\lambda$", "$\\sum \\text{Err}^2$", "$\\sigma^{2}$")
  tabela
}

kable(
  tabela_estatistivas_sigma2(),
  caption = "Comparação entre estimativas de $\\sigma^2$",
  align = 'c',
  digits = 3
)
```


## CC's para EWMA-AR

Foi escolhido um valor para $\lambda$ de 0.2, pois o valor ótimo encontrado foi 0 🫠.

Sabe-se que o valor de $\lambda$ é um valor de suavização, ou seja, quanto mais próximo de 1, mais suavizado é o modelo. E, quanto mais próximo de 0, mais sensível é o modelo, ou seja, quando $\lambda$ se aproxima de 0, o intervalo que denota a região onde a série está em controle se torna mais estreito.


```{r}
df_cc <- data.frame()

for (i in 1:n_simulacoes) {
  observacao <- as.numeric(amostras_subsequentes[[i]])
  phi_0 <- phi_0_para_amostras_seguintes[[i]]
  ewma <- ewma_ar(
    observacao,
    lambda = 0.2
  )
  residuos <- ewma$residuos
  n <- length(residuos)
  df <- data.frame(
    "phi_0" = phi_0,
    "amostra" = 1:n,
    "observacao" = observacao,
    "residuos" = residuos,
    "ewma" = ewma$ewma,
    "limite_inferior" = ewma$ewma - 3 * sqrt(sigma2_lambda),
    "limite_superior" = ewma$ewma + 3 * sqrt(sigma2_lambda)
  )
  df_cc <- rbind(df_cc, df)
}
```

Olhando para a CC para $\phi_0 = 0.2$, que é o valor real de $\phi_0$.

Não ficou igual ao do livro 🥹

```{r}
ggplot(data = df_cc %>% filter(phi_0 == 0.2)) +
  geom_line(aes(x = amostra, y = limite_inferior, color = "Limite Inferior"), linetype = "dashed") +
  geom_line(aes(x = amostra, y = limite_superior, color = "Limite Superior"), linetype = "dashed") +
  geom_line(aes(x = amostra, y = observacao, color = "Amostra")) +
  geom_line(aes(x = amostra, y = ewma, color = "EWMA")) +
  geom_point(data = . %>% filter(observacao < limite_inferior | observacao > limite_superior),
             aes(x = amostra, y = observacao, color = "Fora de controle"), size = 2) +
  labs(x = "Observação", y = "Caracterísitca", color = "Legenda") +
  scale_color_manual(values = c(
    "Amostra" = "black",
    "EWMA" = "blue",
    "Limite Inferior" = "red",
    "Limite Superior" = "red",
    "Fora de controle" = "red"
  )) +
  ggtitle(TeX("EWMA-AR(1) - $\\phi_0 = 0.2$")) +
  theme.base

```


```{r}
ggplot(data = df_cc) +
  geom_line(aes(x = amostra, y = limite_inferior), linetype = "dashed", color = "red", alpha = 0.6) +
  geom_line(aes(x = amostra, y = limite_superior), linetype = "dashed", color = "red", alpha = 0.6) +
  geom_line(aes(x = amostra, y = observacao)) +
  # plot points outside control limits
  geom_point(data = df_cc %>% filter(observacao < limite_inferior | observacao > limite_superior),
             aes(x = amostra, y = observacao), color = "red", alpha = 0.6) +
  labs(x = "Amostra", y = "Característica") +
  ggtitle("EWMA-AR(1)") +
  theme.base +
  facet_wrap(~phi_0)
```

Olhando agora para proporção de amostras fora de controle para cada $\phi_0$.

```{r}
df_fora_controle <- df_cc %>% group_by(phi_0) %>%
  summarise(
    "quantidade" = sum(observacao < limite_inferior | observacao > limite_superior),
    "fora_controle" = 100 * sum(observacao < limite_inferior | observacao > limite_superior) / n()
  )

kable(
  (function() {
    tabela <- df_fora_controle
    colnames(tabela) <- c("$\\phi_0$", "Amostras fora de controle", "Proporção (%)")
    tabela
  })(),
  caption = "Proporção de amostras fora de controle para CC EWMA-AR(1)",
  align = 'c',
  digits = 2
)

ggplot(data = df_fora_controle, aes(x = phi_0, y = fora_controle)) +
  geom_line() +
  labs(x = TeX("$\\phi_0$"), y = "Proporção (%)") +
  ggtitle("Proporção de amostras fora de controle para CC EWMA-AR(1)") +
  theme.base

```


