---
title: "CC para resíduos AR(1)"
output:
  html_document:
    df_print: paged
    theme: paper
    highlight: tango
    toc: true
    toc_float:
      collapsed: true
    code_folding: hide
---

<style>
body {
  font-size: 15px;
}

.table {
  font-size: 12px;
}

.table caption {
  font-size: 13px;
  color: gray;
  font-weight: 600;
}

p {
  text-align: justify;
  text-justify: distribute;
}

.meme-block {
    padding-top: 12px;
}

.meme-block .meme p {
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
}

.meme-block .meme-img {
    display: block;
    max-width: 150px;
    max-height: 150px;
    width: auto;
    height: auto;
}

.bg-danger:not(#dummy) {
  background-color: #f9bdbb;
}

#chart-zoom-modal .modal-dialog {
  width: auto;
  margin: 10px;
}

#chart-zoom-modal .chart-image-preview-wrapper {
  display: flex;
  justify-content: center;
}

#chart-zoom-modal .chart-image-preview {
  width: auto;
  height: 100%;
  max-height: 90vh;
}

.chart-image-wrapper #chart-zoom-button {
  position: absolute;
  top: 0;
  right: 0;
}

.modal-actions {
  position: absolute;
  display: flex;
  justify-content: space-between;
  flex-direction: row-reverse;
  width: calc(100vw - 50px);
}

.modal-actions button {
  opacity: 0.8;
}

.modal-actions button:hover:not(:disabled) {
  opacity: 1;
}
</style>

<script type="text/javascript">
  $(document).ready(function() {
    $('body').prepend(
      // Modal component
      `<div class="modal fade" id="chart-zoom-modal" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content">
            <div class="modal-body">
              <div class="modal-actions">
                <div>
                  <!-- Fullscreen button -->
                  <button type="button" class="btn btn-default btn-sm" id="chart-fullscreen">
                    <span class="glyphicon glyphicon-resize-full"></span>
                  </button>
                  <!-- Close button -->
                  <button type="button" class="btn btn-default btn-sm" data-dismiss="modal">
                    <span class="glyphicon glyphicon-remove"></span>
                  </button>
                </div>
                <!-- Navigation buttons -->
                <div class="modal-navigate">
                  <button type="button" class="btn btn-default btn-sm" id="chart-zoom-prev">
                    <span class="glyphicon glyphicon-chevron-left"></span>
                  </button>
                  <button type="button" class="btn btn-default btn-sm" id="chart-zoom-next">
                    <span class="glyphicon glyphicon-chevron-right"></span>
                  </button>
                </div>
              </div>
              <!-- Chart image -->
              <div class="chart-image-preview-wrapper">
                <img src="" class="chart-image-preview" keepaspectratio="true">
              </div>
            </div>
          </div>
        </div>
      </div>`
    );
    // Add zoom button on top right of each chart
    $('p>img.chart-image').each(function(index) {
      $(this).wrap('<div class="chart-image-wrapper" style="position: relative;"></div>');
      // Add data attribute to identify chart index
      $(this).attr('data-chart-index', index);
      // Button to zoom in
      $(this).parent().append(
        `<button type="button" id="chart-zoom-button" class="btn btn-default btn-sm" data-chart-index="${index}">
          <span class="glyphicon glyphicon-zoom-in"></span>
        </button>`
      );
      // Chart click event
      $(this).siblings('#chart-zoom-button').on('click', function() {
        var chartIndex = $(this).data('chart-index');
        $(`img.chart-image-preview`).attr('src', $(`img.chart-image[data-chart-index=${chartIndex}]`).attr('src'));
        $(`img.chart-image-preview`).attr('data-chart-index', chartIndex);
        updateNavButtonsState();
        // Remove class to avoid fullscreen
        removeFullscreen();
        // Show modal
        $('#chart-zoom-modal').modal('show');
      });
    });
    // Fullscreen button
    $('#chart-fullscreen').on('click', function() {
      toggleFullScreen();
    });
    // Modal navigate buttons
    $('#chart-zoom-prev').on('click', function() {
      showPrevChart();
    });
    $('#chart-zoom-next').on('click', function() {
      showNextChart();
    });
    // Modal arrow keys to navigate charts
    $(document).keydown(function(e) {
      if ($('#chart-zoom-modal').is(':visible')) {
        if (e.keyCode == 37) {
          showPrevChart();
          e.preventDefault();
        } else if (e.keyCode == 39) {
          showNextChart();
          e.preventDefault();
        }
      }
    });
    function removeFullscreen() {
      $(`img.chart-image-preview`).removeClass('fullscreen');
      $(`img.chart-image-preview`).css('max-height', '90vh');
      $('#chart-fullscreen').find('span').removeClass('glyphicon-resize-small').addClass('glyphicon-resize-full');
    }
    function addFullscreen() {
      $(`img.chart-image-preview`).addClass('fullscreen');
      $(`img.chart-image-preview`).css('max-height', 'none');
      $('#chart-fullscreen').find('span').removeClass('glyphicon-resize-full').addClass('glyphicon-resize-small');
    }
    function toggleFullScreen(fullScreenState) {
      if ($(`img.chart-image-preview`).hasClass('fullscreen')) {
        removeFullscreen();
      } else {
        addFullscreen();
      }
    }
    function showPrevChart() {
      var chartIndex = parseInt($(`img.chart-image-preview`).attr('data-chart-index'));
      if (chartIndex > 0) {
        chartIndex -= 1;
        $(`img.chart-image-preview`).attr('src', $(`img.chart-image[data-chart-index=${chartIndex}]`).attr('src'));
        $(`img.chart-image-preview`).attr('data-chart-index', chartIndex);
        updateNavButtonsState();
      }
    }
    function showNextChart() {
      var chartIndex = parseInt($(`img.chart-image-preview`).attr('data-chart-index'));
      if (chartIndex < $('img.chart-image').length - 1) {
        chartIndex += 1;
        $(`img.chart-image-preview`).attr('src', $(`img.chart-image[data-chart-index=${chartIndex}]`).attr('src'));
        $(`img.chart-image-preview`).attr('data-chart-index', chartIndex);
        updateNavButtonsState();
      }
    }
    // Disable nav buttons if at the end
    function updateNavButtonsState() {
      var chartIndex = parseInt($(`img.chart-image-preview`).attr('data-chart-index'));
      if (chartIndex == 0) {
        $('#chart-zoom-prev').prop('disabled', true);
      } else {
        $('#chart-zoom-prev').prop('disabled', false);
      }
      if (chartIndex == $('img.chart-image').length - 1) {
        $('#chart-zoom-next').prop('disabled', true);
      } else {
        $('#chart-zoom-next').prop('disabled', false);
      }
    }
  });
</script>

```{r echo=TRUE, message=FALSE, warning=FALSE}
Sys.setenv(lang = "en_US")

library(ggplot2)
library(forecast) # plot ts objects
library(knitr)
library(grid) # textGrob
library(gridExtra) # grid.arrange
library(latex2exp) # latex expressions
library(tidyr)
library(dplyr)
```

```{r}
knitr::opts_chunk$set(
  out.height = "\\textheight",
  out.width = "\\textwidth",
  out.extra = 'keepaspectratio=true class="chart-image"',
  fig.align = "center"
)
```


```{r}
theme.base <- theme_minimal(base_size = 11) +
  theme(
    axis.text = element_text(size = 8),
    plot.title = element_text(hjust = 0.5, size = 10, face = "bold"),
    axis.title = element_text(size = 8),
    legend.title = element_text(size = 8),
    panel.grid.major = element_line(colour = "grey90", linewidth = 0.5),
    panel.grid.minor = element_line(colour = adjustcolor("grey90", alpha.f = 0.4), linewidth = 0.5),
    panel.border = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    axis.line.x = element_line(colour = "grey"),
    axis.line.y = element_line(colour = "grey"),
  )

theme.no_legend <- theme(legend.position = "none")

theme.no_grid <-  theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()
)

theme.no_axis <- theme(
  axis.line.x = element_blank(),
  axis.line.y = element_blank()
)

theme.no_axis_title <- theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank()
)

# Theme for timeseries
theme.ts <- theme.base +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  ) +
  theme.no_legend

```


```{r}
# Função para simulação de amostras de um AR(1)
# 
# @param parametros lista com os parâmetros do modelo AR(1):
# \describe{
#   \item{n}{número de observações}
#   \item{phi}{parâmetro de auto-regressão}
#   \item{media}{média da distribuição do efeto aleatório}
#   \item{sd}{desvio padrão da distribuição do efeto aleatório}
#   \item{x1}{valor inicial da série}
# }
simulacao_ar_1 <- function(parametros) {
  n <- parametros$n + 1
  serie <- numeric(n)
  ifelse(is.null(parametros$x1), serie[1] <- rnorm(1), serie[1] <- parametros$x1)
  
  media_pop <- ifelse(!is.numeric(parametros$media), 0, parametros$media)
  sd_pop <- ifelse(!is.numeric(parametros$sd), 1, parametros$sd)
  
  for (i in 2:n) {
    serie[i] <- parametros$phi * serie[i - 1] + rnorm(1, mean = media_pop, sd = sd_pop)
  }
  
  return(serie[-1])
}
```


## Série para criação dos limites de controle

```{r}
PARAMETROS <- data.frame(
  phi = 0.2,
  media = 0,
  sd = 1,
  n_h0 = 100,
  n_h1 = 200
)

```


```{r}
set.seed(1)

# amostra_inicial <- arima.sim(n = n_h0, model = list(ar = phi_0))
amostra_inicial <- simulacao_ar_1(list(n = PARAMETROS$n_h0, phi = PARAMETROS$phi_0))
modelo <- arima(amostra_inicial, order = c(1, 0, 0), include.mean = FALSE)
residuos <- modelo$residuals
modelo
```


```{r}
grid.arrange(
  autoplot(residuos) + ggtitle("Resíduos do modelo AR(1)") + theme.base + theme.ts,
  ggAcf(residuos) + ggtitle("ACF dos resíduos") + theme.base,
  ggPacf(residuos) + ggtitle("PACF dos resíduos") + theme.base,
  layout_matrix = rbind(c(1, 1), c(2, 3))
)
```

### Limites de controle


```{r message=FALSE, warning=FALSE}
alpha <- 0.05
desvio_padrao <- sd(residuos)
max_devio <- qnorm(1 - alpha/2) * desvio_padrao
limites <- mean(residuos) + c(-max_devio, max_devio)

tabela_estatisticas_residuos <- function() {
  tabela <- data.frame(
    "mean" = mean(residuos),
    "sd" = desvio_padrao,
    "IL" = limites[1],
    "SL" = limites[2]
  )
  colnames(tabela) <- c("Média", "Desvio padrão", "Limite inferior", "Limite superior")
  t(tabela)
}

knitr::kable(
  tabela_estatisticas_residuos(),
  caption = "Intervalo de confiança dos resíduos",
  align = 'c',
  digits = 3
)
```


```{r message=FALSE, warning=FALSE}
phi_0_para_amostras_seguintes <- seq(0, 0.8, by = 0.1)
n_simulacoes <- length(phi_0_para_amostras_seguintes)

# primeiro valor das amostras subsequentes
x0 <- amostra_inicial[length(amostra_inicial)]
n_h1 <- 200

amostras_subsequentes <- lapply(phi_0_para_amostras_seguintes, function(phi_0) arima.sim(n = n_h1, model = list(ar = c(phi_0))))

```


## Simulações

Amostras subsequentes para $\phi_0 \in \{0, 0.1, 0.2, \ldots, 0.8\}$ com $n = 200$.


```{r, fig.height = 10}
graficos_series <- function(dados) {
  lista <- c()
  for (i in 1:(n_simulacoes)) {
    lista[[i]] <- autoplot(amostras_subsequentes[[i]]) +
      ggtitle(TeX(sprintf("$\\phi_0=%.1f$", phi_0_para_amostras_seguintes[i]))) +
      theme.base +
      theme.no_axis_title
  }
  lista
}

graficos_resid <- function(dados) {
  lista <- c()
  for (i in 1:(n_simulacoes)) {
    lista[[i]] <- ggAcf(amostras_subsequentes[[i]]) +
      ggtitle(TeX(sprintf("$\\phi_0=%.1f$", phi_0_para_amostras_seguintes[i]))) +
      theme.base +
      theme.no_axis_title
  }
  lista
}

grid.arrange(
  grobs = (
    \() {
      lista_graficos <- c()
      
      # Séries
      lista_graficos[[2]] <- textGrob("Séries", gp = gpar(fontface = "bold", fontsize = 12))
      lista_graficos[[3]] <- textGrob("")
      lista_graficos <- c(lista_graficos, graficos_series(amostras_subsequentes))
      
      # Resíduos
      lista_graficos[[length(lista_graficos) + 2]] <- textGrob("ACFs", gp = gpar(fontface = "bold", fontsize = 12))
      lista_graficos[[length(lista_graficos) + 1]] <- textGrob("")
      lista_graficos <- c(lista_graficos, graficos_resid(amostras_subsequentes))
      lista_graficos
    }
  )(),
  ncol = 3,
  widths = c(1, 1, 1)
)

```

## Cartas de controle para os resíduos


```{r}
residuos_subsequentes <- lapply(amostras_subsequentes, function(amostra) {
  # FIXME: Devo ajustar o modelo para cada amostra?
  # modelo <- arima(amostra, order = c(1, 0, 0), include.mean = FALSE)
  # modelo$residuals
  Arima(amostra, model = modelo)$residuals
})


cartas_controle <- function(dados) {
  lista <- c()
  for (i in 1:(n_simulacoes)) {
    residuos <- residuos_subsequentes[[i]]
    resid_layer <- autolayer(residuos_subsequentes[[i]])
    fora_de_controle = resid_layer$layer_data() %>% filter(seriesVal < limites[1] | seriesVal > limites[2])
    
    lista[[i]] <- autoplot(residuos) +
      geom_hline(yintercept = limites, linetype = "dashed", color = "red", alpha = 0.6) +
      geom_point(data = fora_de_controle, aes(x = timeVal, y = seriesVal), color = "red") +
      theme.base +
      theme.no_axis_title +
      theme(legend.position = "none") +
      labs(x = "Resíduos", y = "Observação") +
      ggtitle(TeX(sprintf("$\\phi_0=%.1f$", phi_0_para_amostras_seguintes[i])))
  }
  lista
}

grid.arrange(
  grobs = (
    \() {
      lista_graficos <- c()
      lista_graficos[[2]] <- textGrob("Resíduos", gp = gpar(fontface = "bold", fontsize = 12))
      lista_graficos[[3]] <- textGrob("")
      lista_graficos <- c(lista_graficos, cartas_controle(amostras_subsequentes))
      lista_graficos
    }
  )(),
  ncol = 3,
  widths = c(1, 1, 1)
)
```

### Quantidade de amostras fora de controle para cada $\phi_0$

```{r results = 'asis'}
quantidade_fora_de_controle <- sapply(residuos_subsequentes, function(residuos) {
  sum(residuos < limites[1] | residuos > limites[2])
})

tabela_estatisticas_amostras <- function() {
  tabela <- data.frame(
    "phi_0" = phi_0_para_amostras_seguintes,
    "fora" = quantidade_fora_de_controle,
    "prop" = 100 * quantidade_fora_de_controle / n_h1
  )
  colnames(tabela) <- c("$\\phi_0$", "Amostras fora de controle", "Proporção (%)")
  tabela
}

ggplot(tabela_estatisticas_amostras(), aes(x = `$\\phi_0$`, y = `Amostras fora de controle`)) +
  geom_point() +
  geom_line() +
  labs(x = TeX("$\\phi_0$"), y = "Amostras fora de controle") +
  ggtitle(TeX("Amostras fora de controle para cada $\\phi_0$")) +
  theme.base

kable(
  tabela_estatisticas_amostras(),
  caption = "Quantidade de amostras fora de controle para cada $\\phi_0$",
  align = 'c',
  digits = 3
)

```



## EWMA-AR

Minimizando a soma dos quadrados dos resíduos para encontrar o melhor valor de $\lambda$.

Temos que $\lambda \in (0, 1]$, além disso, a previsão para a observação $x_{t+1}$ é dada por $\hat{x}_{t+1}(t)=z_{t} = \lambda x_t + (1 - \lambda) z_{t-1}$.
E, segundo Montgomery, Eq. 10.16, temos que os erros de previsão são dados por $e_t = x_t - \hat{x}_t(t-1)$.

```{r message=FALSE, warning=FALSE}
ewma_ar <- function(dados, lambda, funcao_erro) {
  n <- length(dados)
  ewma <- numeric(n)
  ewma[1] <- dados[1]
  for (i in 2:n) {
    ewma[i] <- lambda * dados[i] + (1 - lambda) * ewma[i - 1]
  }
  data.frame(ewma = ewma, residuos = funcao_erro(ewma))
}

# Verificando com t-1
verifica_lambda_com_t_1 <- function(lambda) {
  n <- length(amostra_inicial)
  ewma <- ewma_ar(
    amostra_inicial,
    lambda = lambda,
    funcao_erro = \(ewma_) amostra_inicial - ewma_ * (1:n - 1)
  )
  sum(ewma$residuos^2)
}

# Verificando sem t-1
verifica_lambda_sem_t_1 <- function(lambda) {
  ewma <- ewma_ar(
    amostra_inicial,
    lambda = lambda,
    funcao_erro = \(ewma_) amostra_inicial - ewma_
  )
  sum(ewma$residuos^2)
}

# Salvando para plotar
lambdas_arima_verificados <- c()
soma_arima_quadrados <- c()

# Verificando com ARIMA
verifica_lambda_arima <- function(lambda) {
  ewma <- ewma_ar(
    amostra_inicial,
    lambda = lambda,
    funcao_erro = \(ewma_) Arima(ewma_, model = modelo)$residuals
  )
  soma <- sum(ewma$residuos^2)
  lambdas_arima_verificados <<- c(lambdas_arima_verificados, lambda)
  soma_arima_quadrados <<- c(soma_arima_quadrados, soma)
  soma
}

lambda_arima_otimo <- optimize(verifica_lambda_arima, c(0, 1))
lambda_com_t_1_otimo <- optimize(verifica_lambda_com_t_1, c(0, 1))
lambda_sem_t_1_otimo <- optimize(verifica_lambda_sem_t_1, c(0, 1))

lambdas_arima_df <- data.frame(lambda = lambdas_arima_verificados, erro = soma_arima_quadrados)
```




```{r message=FALSE, warning=FALSE}
ggplot(data = lambdas_arima_df) +
  geom_line(aes(x = lambda, y = erro)) +
  geom_vline(xintercept = lambda_arima_otimo$minimum, linetype = "dashed", color = "red") +
  annotate("text", x = lambda_arima_otimo$minimum, y = 0,
           label = TeX(sprintf("$\\lambda=%.3f$", lambda_arima_otimo$minimum)), color = "red",
           hjust = -0.1, vjust = -0.2, na.rm = T, angle = 90) +
  labs(x = TeX("$\\lambda$"), y = "Soma dos quadrados dos resíduos") +
  ggtitle(TeX("Soma dos quadrados dos resíduos para diferentes valores de $\\lambda$\ncom o modelo ARIMA")) +
  theme.base
```



Segundo Montgomery, podemos estimar o valor de $\sigma^2$ para o modelo EWMA-AR como $\sigma^2 = \frac{\sum (\text{err}_i^2|_\lambda)}{n}$. Onde $\text{err}|_\lambda$ são os resíduos do modelo EWMA-AR para o melhor valor de $\lambda$ encontrado.

```{r}
sigma2_arima <- lambda_arima_otimo$objective / n_h0
sigma2_com_t_1 <- lambda_com_t_1_otimo$objective / n_h0
sigma2_sem_t_1 <- lambda_sem_t_1_otimo$objective / n_h0
sigma2_sd <- sd(residuos)

tabela_estatistivas_sigma2 <- function() {
  tabela <- data.frame(
    "modelo" = c("sd(modelo)", "ARIMA", "Com $t-1$", "Sem $t-1$"),
    "lambda" = c(NA, lambda_arima_otimo$minimum, lambda_com_t_1_otimo$minimum, lambda_sem_t_1_otimo$minimum),
    "sigma2" = c(sigma2_sd, sigma2_arima, sigma2_com_t_1, sigma2_sem_t_1),
    "erro" = c(sum(modelo$residuals^2), lambda_arima_otimo$objective, lambda_com_t_1_otimo$objective, lambda_sem_t_1_otimo$objective)
  )
  colnames(tabela) <- c("Modelo", "$\\lambda$", "$\\sigma^{2}$", "Erro")
  tabela
}

kable(
  tabela_estatistivas_sigma2(),
  caption = "Comparação entre estimativas de $\\sigma^2$",
  align = 'c',
  digits = 3
)
```


## CC's para EWMA-AR

```{r}
df_cc <- data.frame()

sigma2_usado <- sigma2_sd
# sigma2_usado <- sigma2_lambda

for (i in 1:n_simulacoes) {
  observacao <- amostras_subsequentes[[i]]
  phi_0 <- phi_0_para_amostras_seguintes[[i]]
  ewma <- ewma_ar(
    observacao,
    lambda = lambda_arima_otimo$minimum,
    funcao_erro = \(ewma_) Arima(ewma_, model = modelo)$residuals
  )
  residuos <- ewma$residuos
  n <- length(residuos)
  df <- data.frame(
    "phi_0" = phi_0,
    "amostra" = 1:(n - 1),
    "observacao" = observacao[1:n - 1],
    "residuos" = residuos[1:n - 1],
    "ewma" = ewma$ewma[2:n],
    "limite_inferior" = ewma$ewma[2:n] - 3 * sqrt(sigma2_usado),
    "limite_superior" = ewma$ewma[2:n] + 3 * sqrt(sigma2_usado)
  )
  df_cc <- rbind(df_cc, df)
}
```

Olhando para a CC para $\phi_0 = 0.2$, que é o valor real de $\phi_0$.

Não ficou igual ao do livro 🥹

```{r}
ggplot(data = df_cc %>% filter(phi_0 == 0.2)) +
  geom_line(aes(x = amostra, y = limite_inferior, color = "Limite Inferior"), linetype = "dashed") +
  geom_line(aes(x = amostra, y = limite_superior, color = "Limite Superior"), linetype = "dashed") +
  geom_line(aes(x = amostra, y = observacao, color = "Amostra")) +
  geom_line(aes(x = amostra, y = ewma, color = "EWMA")) +
  geom_point(data = . %>% filter(observacao < limite_inferior | observacao > limite_superior),
             aes(x = amostra, y = observacao, color = "Fora de controle"), size = 2) +
  labs(x = "Observação", y = "Caracterísitca", color = "Legenda") +
  scale_color_manual(values = c(
    "Amostra" = "black",
    "EWMA" = "blue",
    "Limite Inferior" = "red",
    "Limite Superior" = "red",
    "Fora de controle" = "red"
  )) +
  ggtitle(TeX("EWMA-AR(1) - $\\phi_0 = 0.2$")) +
  theme.base

```


```{r}
ggplot(data = df_cc) +
  geom_line(aes(x = amostra, y = limite_inferior), linetype = "dashed", color = "red", alpha = 0.6) +
  geom_line(aes(x = amostra, y = limite_superior), linetype = "dashed", color = "red", alpha = 0.6) +
  geom_line(aes(x = amostra, y = observacao)) +
  # plot points outside control limits
  geom_point(data = df_cc %>% filter(observacao < limite_inferior | observacao > limite_superior),
             aes(x = amostra, y = observacao), color = "red", alpha = 0.6) +
  labs(x = "Amostra", y = "Característica") +
  ggtitle("EWMA-AR(1)") +
  theme.base +
  facet_wrap(~phi_0)
```

Olhando agora para proporção de amostras fora de controle para cada $\phi_0$.

```{r}
df_fora_controle <- df_cc %>% group_by(phi_0) %>%
  summarise(
    "quantidade" = sum(observacao < limite_inferior | observacao > limite_superior),
    "fora_controle" = 100 * sum(observacao < limite_inferior | observacao > limite_superior) / n()
  )

kable(
  (function() {
    tabela <- df_fora_controle
    colnames(tabela) <- c("$\\phi_0$", "Amostras fora de controle", "Proporção (%)")
    tabela
  })(),
  caption = "Proporção de amostras fora de controle para CC EWMA-AR(1)",
  align = 'c',
  digits = 2
)
```


